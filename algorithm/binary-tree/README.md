[TOC]

# 基本概念
- 深度
- 广度
- 叶子节点、非叶子节点
...


- 遍历
	- 前、中、后：递归，栈
	- 分层（宽度）：队列


方便理解，可以认为叶子节点也有孩子，左右都为 null


## 一个二叉树问题的通用思考过程
1.是否可以通过遍历一遍二叉树得到答案？
* 如果可以，用一个 traverse 函数配合外部变量来实现。

2.是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案？
* 如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值。  

3.无论使用哪一种思维模式，你都要明白二叉树的每一个节点需要做什么，需要在什么时候（前中后序）做。

就是`遍历` `分解问题（子问题）` 两种思路

# 递归
> 大部分二叉树问题都用递归思维，所有的递归解都可以从二叉树问题出发

先想怎么构造函数签名，一般来说，返回值就是最终结果
不要因为觉得复杂就不敢实现，人脑压栈很困难，容易把问题想复杂

 动态规划，回溯算法，分治算法，图论算法等等，都可以从二叉树问题出发

 如果你告诉我，快速排序就是个二叉树的前序遍历，归并排序就是个二叉树的后序遍历，那么我就知道你是个算法高手了。

## 递归序
深度遍历，每个节点要被访问 3 次


## DFS
尽可能搜到底，用栈，递归
「一条路走到底，不撞南墙不回头」
https://leetcode.cn/leetbook/read/dfs/euoui2/


### 遍历框架 labuladong
这一套模版，可以引申出很多题目
```golang
// 基本的二叉树节点
type TreeNode struct {
    val int
    left *TreeNode
    right *TreeNode
}

// 后序遍历二叉树
func traverse(root *TreeNode) {
    if root != nil {
        traverse(root.left)
        traverse(root.right)
    }
}
```

#### 前序

前序位置本身其实没有什么特别的性质，之所以你发现好像很多题都是在前序位置写代码，实际上是因为我们习惯把那些对前中后序位置不敏感的代码写在前序位置罢了。


#### 中序

#### 后序
* 先处理子树再汇总
##### 后序位置的特殊之处 
* 后序遍历特别重要，涉及到处理子树的问题，比如二叉树的直径，路径和等等，都用到了后序遍历的思想。

* 你可以发现，前序位置的代码执行是自顶向下的，而后序位置的代码执行是自底向上的

`后序位置的代码不仅可以获取参数数据，还可以获取到子树通过函数返回值传递回来的数据。`


## BFS
尽可能横向搜，用队列



# 非递归

## 不能只会递归啊！！

任何递归都可以改成非递归实现
> 递归不是玄学，只是系统帮你压栈  -- 左神

所以说，非递归就是考察手写栈，也可以看做`最基本的回溯思想`
比较少见的，有时也考察滑动窗口什么的技巧

#### 准备一个栈数据结构！！！
structure/stack.go 代码在这里
我们可以不实现，但是要定义好接口，比如 `Push` `Pop` `Top` `IsEmpty` `Len`

##### 前序遍历
最简单

注意进栈顺序，先压右再压左

##### 中序遍历

要用个临时指针，因为访问和操作不一致

##### 后序遍历

要用个临时指针，保存上一个访问的节点，目的是记录右孩子是否访问过

如果只是打印，那么可以稍稍修改前序遍历，先压左再压右，能得到`后序遍历的倒序` 再做数组反转就行


# N 叉树
> 就是节点有 N 个孩子的树，用数组保存指向孩子的指针
## 遍历模版
```golang
// 基本的 N 叉树节点
type TreeNode struct {
    val int
    children []*TreeNode
}

func traverse(root *TreeNode) {
    for _, child := range root.children {
        traverse(child)
    }
}
```

> N叉树没有中序遍历！

## 几种特殊的树，放到搜索模块，这里不展开

- AVL(平衡二叉树)

- 二叉搜索树 BST