[TOC]

# 基本概念
- 深度
- 广度
- 叶子节点、非叶子节点
...


- 遍历
	- 前、中、后：递归，栈
	- 分层（宽度）：队列


方便理解，可以认为叶子节点也有孩子，左右都为 null


## 一个二叉树问题的通用思考过程
1.是否可以通过遍历一遍二叉树得到答案？
* 如果可以，用一个 traverse 函数配合外部变量来实现。

2.是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案？
* 如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值。  

3.无论使用哪一种思维模式，你都要明白二叉树的每一个节点需要做什么，需要在什么时候（前中后序）做。

就是`遍历` `分解问题（子问题）` 两种思路

* 其中「遍历」的思路扩展延伸一下就是[回溯算法](../backtrack/README.md)
* 「分解问题」的思路可以扩展成[动态规划算法](../dp/README.md)

# 递归
> 大部分二叉树问题都用递归思维，所有的递归解都可以从二叉树问题出发

先想怎么构造函数签名，一般来说，返回值就是最终结果
不要因为觉得复杂就不敢实现，人脑压栈很困难，容易把问题想复杂


动态规划，回溯算法，分治算法，图论算法等等，都可以从二叉树问题出发
* 如果你告诉我，快速排序就是个二叉树的前序遍历，归并排序就是个二叉树的后序遍历，那么我就知道你是个算法高手了。


## 退出条件
想象特殊情况：
- 到叶子节点了（问题不能再分解，栈顶），怎么操作
	- 求最大深度，最小深度
- 到栈底（后续遍历的根节点），怎么操作
	- 二叉树转链表


## 递归函数技巧
- 递归函数的返回值通常是当前节点下的某种答案，比如最大深度、最小深度、是否是平衡二叉树等等。
	- 要用合适的变量接住递归函数的返回值
		- e.g `root.left`, `root.right`
	- 如果是递归操作数组，增加`开始结束下标`作为入参，这样不用在原数组上修改，便于理解
		- e.g 已知前序中序遍历构造二叉树
		- 实在想不出怎么取下标，可以声明个取下标的函数，把代码框架先搭起来
- golang 特殊处理
	- 不想定义对象的话，声明一个 traverse 匿名函数的签名，再实现，就可以递归调用匿名函数了
	- traverse 函数的第一次调用，入参就是全局出发点
		- e.g 整个树根节点，或者整个数组
		- 递归的时候，不断缩小范围，比如左右子树，或者数组的一部分（下标控制）




## DFS
尽可能搜到底，用栈，递归
「一条路走到底，不撞南墙不回头」
https://leetcode.cn/leetbook/read/dfs/euoui2/

### 递归序 左神
深度遍历，每个节点要被访问 3 次

### 遍历框架 labuladong
这一套模版，可以引申出很多题目
```golang
// 基本的二叉树节点
type TreeNode struct {
    val int
    left *TreeNode
    right *TreeNode
}

// 后序遍历二叉树
func traverse(root *TreeNode) {
    if root != nil {
        traverse(root.left)
        traverse(root.right)
    }
}
```

#### 前序

前序位置本身其实没有什么特别的性质，之所以你发现好像很多题都是在前序位置写代码，实际上是因为我们习惯把那些对前中后序位置不敏感的代码写在前序位置罢了。


#### 中序

#### 后序
* 先处理子树再汇总
##### 后序位置的特殊之处 
* 后序遍历特别重要，涉及到处理子树的问题（子节点、叶子节点），比如二叉树的直径，路径和等等，都用到了后序遍历的思想。
  - 左右子节点都处理了，才处理父节点
* 你可以发现，前序位置的代码执行是自顶向下的，而后序位置的代码执行是自底向上的

`后序位置的代码不仅可以获取参数数据，还可以获取到子树通过函数返回值传递回来的数据。`


## BFS
尽可能横向搜，用队列


## 优化：备忘录
递归的开销很大，并且有很多重复计算
可以通过一个数组缓存已经计算过的值，减少重复计算


# 非递归

## 不能只会递归啊！！

任何递归都可以改成非递归实现
> 递归不是玄学，只是系统帮你压栈  -- 左神

所以说，非递归就是考察手写栈，也可以看做`最基本的回溯思想`
比较少见的，有时也考察滑动窗口什么的技巧

#### 准备一个栈数据结构！！！
structure/stack.go 代码在这里
我们可以不实现，但是要定义好接口，比如 `Push` `Pop` `Top` `IsEmpty` `Len`

##### 前序遍历
最简单

注意进栈顺序，先压右再压左

##### 中序遍历

要用个临时指针，因为访问和操作不一致

##### 后序遍历

要用个临时指针，保存上一个访问的节点，目的是记录右孩子是否访问过

如果只是打印，那么可以稍稍修改前序遍历，先压左再压右，能得到`后序遍历的倒序` 再做数组反转就行


# N 叉树
> 就是节点有 N 个孩子的树，用数组保存指向孩子的指针
## 遍历模版
```golang
// 基本的 N 叉树节点
type TreeNode struct {
    val int
    children []*TreeNode
}

func traverse(root *TreeNode) {
    for _, child := range root.children {
        traverse(child)
    }
}
```

> N叉树没有中序遍历！

## 几种特殊的树，放到搜索模块，这里不展开

- AVL(平衡二叉树)

- 二叉搜索树 BST