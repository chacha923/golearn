[TOC]
# 动态规划 DP

## 解题框架

### 特点
1. 存在重叠子问题
2. （重要）状态转移方程
3. 能找到最优子结构
求最值
穷举

### 套路
1. 明确《状态》
2. 明确《选择》
3. 明确 dp 函数/数组的定义
4. 明确 base case

## 线性动态规划

https://leetcode.cn/leetbook/detail/dynamic-programming-1-plus/ 
动态规划图文学：线性 & 区间动态

dp[n] := [0..n] 上问题的解




### 双串, 大部分问题都是双串
有两个输入从串，长度分别为 m, n，此时子问题需要用 i, j 两个变量表示，分别代表第一个串和第二个串考虑的位置 dp[i][j]:=第一串考虑[0..i]，第二串考虑[0..j]时，原问题的解

> dp[i][j] = f(dp[i-1][j-1], dp[i-1][j], dp[i][j-1])

```
for i = 1..m
    for j = 1..n
        dp[i][j] = f(dp[i-1][j-1], dp[i-1][j], dp[i][j-1])
```

#### 初始化 base case
通常要先初始化下标为 0 的行和列，表示空串的情况
dp[0][0][...] = base

#### 确定 dp 的遍历顺序

example：
- 最长公共子序列
- 两个字符串的最小 ASCII 删除和 —— LCS，len 和 ascii 各一个 dp
- 最长重复子数组 —— 最长公共子串，注意与最长公共子序列的区别
- 0 1 背包问题

#### 空间压缩技巧
满足某些条件的话，双串问题可以转为单串

> 能够使用空间压缩技巧的动态规划都是二维 dp 问题，你看它的状态转移方程，如果计算状态 dp[i][j] 需要的都是 dp[i][j] 相邻的状态，那么就可以使用空间压缩技巧，将二维的 dp 数组转化成一维，将空间复杂度从 O(N^2) 降低到 O(N)。


前缀和

### 单串

状态转移方程

> dp[n] = f(dp[n-1], ..., dp[0])

从以上状态定义和状态转移可以看出，大规模问题的状态只与较小规模的问题有关，而问题规模完全用一个变量 i 表示，i 的大小表示了问题规模的大小，因此从小到大推 i 直至推到 n，就得到了大规模问题的解，这就是线性动态规划的过程。

example：

- 爬楼梯
- 跳跃到数组末尾最少走几步

明显需要用递归解决的问题，已知规模为 n-1 的解，求规模为 n 时的解。需要知道何时退出，以及 n 为初始值的解（0 1 2）

拆分为小规模的子问题
